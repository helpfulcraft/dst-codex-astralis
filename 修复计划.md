# 只有老奶奶能读
# 攻略目录升级
# 添加个人todolist
好的，我们来详细梳理这两个功能的实现思路。

---

### 一、 “是否切换视图应该由用户决定” 的实现思路

这个问题的核心是解耦“数据更新”和“UI视图切换”。当后台数据（如团队计划）更新时，我们只应该默默地更新UI控件的内容，而不是粗暴地把用户的界面切换  过去。

#### **当前的问题代码**

在 `AtlasBookUI:UpdateTaskList` 函数的末尾：

```lua
-- ... (代码前面部分) ...
print("[万象全书] 任务列表UI更新完成，共显示 " .. tostring(#self.task_items) .. " 个任务项")

-- 确保规划器视图是可见的 -- <--- 问题根源在这里
if self.planner_view then
    print("[万象全书] 确保规划器视图可见")
    if not self.planner_view:IsVisible() then
        print("[万象全书] 规划器视图不可见，尝试显示")
        self.planner_view:Show()
        self.guide_view:Hide()
    end

    -- 重新设置视图状态
    self.current_view = "planner"
    self.planner_tab_button:SetTextColour(0.8, 0, 0, 1) -- Red
    self.guide_tab_button:SetTextColour(0, 0, 0, 1) -- Black
    print("[万象全书] 视图状态已重置为规划器")
end
```

#### **修改步骤**

**1. 剥离视图切换逻辑**

首先，将 `UpdateTaskList` 函数变得“纯粹”，让它只负责更新任务列表的UI，不再关心视图是否可见。

**修改后的 `UpdateTaskList` 函数：**
```lua
function AtlasBookUI:UpdateTaskList()
    print("[万象全书] 开始更新任务列表UI")

    -- 清除现有任务项 (或者使用更高效的UI复用逻辑)
    if self.task_items then
        for _, item in pairs(self.task_items) do
            if item and item.Kill then
                item:Kill()
            end
        end
    end
    self.task_items = {}

    -- ... (获取任务列表的逻辑不变) ...
    local tasks = TheWorld.components.atlas_todolist:GetTasks() or {}
    print("[万象全书] 准备创建 " .. tostring(#tasks) .. " 个任务项")

    -- ... (创建和添加新任务项的循环逻辑不变) ...
    local y_offset = 200
    for i, task_data in ipairs(tasks) do
        -- ... 创建 task_item ...
        task_item:SetPosition(0, y_offset, 0)
        self.task_list:AddChild(task_item)
        table.insert(self.task_items, task_item)
        y_offset = y_offset - 60
    end

    print("[万象全书] 任务列表UI更新完成，共显示 " .. tostring(#self.task_items) .. " 个任务项")
    -- 注意：函数到这里就结束了，删掉后面所有关于 self.planner_view:Show() 和设置颜色的代码。
end
```

**2. 在正确的地方调用更新**

现在 `UpdateTaskList` 不会自动显示视图了，我们需要在用户主动切换到“团队计划”视图时，确保列表是最新的。

修改 `SetView` 函数：

```lua
function AtlasBookUI:SetView(view_name)
    self.current_view = view_name
    
    if view_name == "guide" then
        self.guide_view:Show()
        self.planner_view:Hide()
        self.guide_tab_button:SetTextColour(0.8, 0, 0, 1) -- Red
        self.planner_tab_button:SetTextColour(0, 0, 0, 1) -- Black
    elseif view_name == "planner" then
        self.guide_view:Hide()
        self.planner_view:Show()
        self.guide_tab_button:SetTextColour(0, 0, 0, 1) -- Black
        self.planner_tab_button:SetTextColour(0.8, 0, 0, 1) -- Red
        
        -- 关键：在切换到 planner 视图时，调用一次更新，确保显示的是最新内容。
        self:UpdateTaskList()
    end
end
```

**3. 修改事件监听器**

事件监听器的回调函数现在也应该只调用 `UpdateTaskList`，让它在后台默默更新数据，而不会影响用户当前正在看的攻略页面。

修改 `_ctor` 中的事件监听器：

```lua
-- 在 AtlasBookUI 的 _ctor 函数中
-- ...
if not self.task_update_listener then
    self.task_update_listener = TheWorld:ListenForEvent("atlas_todolist_updated", function()
        print("[万象全书] 收到任务列表更新事件，后台刷新UI")
        -- 这里直接调用纯粹的更新函数
        self:UpdateTaskList()
    end)
    print("[万象全书] 已设置全局任务更新监听器")
end
-- ...
```
这里有一个小优化：如果当前视图正好是 `planner`，可以立即刷新；如果不是，甚至可以只更新数据，等切换过去再刷新UI。但为了简单起见，直接后台刷新UI是最直接的。

**总结：** 通过以上三步修改，我们就实现了目标。数据更新事件 (`atlas_todolist_updated`) 会触发后台的UI重建，但不会改变用户当前的视图。只有当用户自己点击“团队计划”标签时，才会显示那个已经被更新好的任务列表。

---

### 二、 混合方案（团队计划 + 个人计划）的实现思路

这个方案需要在后端数据和前端UI上都做扩展。

#### **第1步：后端 - 创建个人计划组件**

我们需要一个新的组件来存储每个玩家的个人任务列表。这个组件应该挂在玩家身上。

**`atlas_personaltodolist.lua` (新建一个文件):**
```lua
local AtlasPersonalTodoList = Class(function(self, inst)
    self.inst = inst
    self.tasks = {}
    self.next_id = 1
    -- 这个组件非常简单，因为它不需要复杂的C/S同步逻辑
    -- 客户端可以直接修改，然后通过RPC通知服务器存档即可
end)

function AtlasPersonalTodoList:AddTask(text)
    -- ... (添加任务到 self.tasks) ...
    -- 通知服务器存档
    if not self.inst.ismastersim then
        SendModRPCToServer(MOD_RPC[ATLAS_RPC.NAMESPACE][ATLAS_RPC.UPDATE_PERSONAL_TASKS], json.encode(self.tasks))
    end
end

-- ... 实现 ToggleTask, DeleteTask, GetTasks 等方法 ...
-- ... 实现 OnSave 和 OnLoad 用于存档 ...

-- 添加一个方法，让服务器可以更新客户端的数据
function AtlasPersonalTodoList:UpdateTasksFromServer(tasks_json)
    local success, tasks = pcall(function() return json.decode(tasks_json) end)
    if success and tasks then
        self.tasks = tasks
        -- 触发UI更新事件
        self.inst:PushEvent("atlas_personaltodolist_updated")
    end
end

return AtlasPersonalTodoList
```

**在 `modmain.lua` 中：**
1.  **挂载组件**：在 `AddPlayerPostInit` 中为每个玩家添加这个新组件：`inst:AddComponent("atlas_personaltodolist")`。
2.  **注册新的RPC**：添加 `ATLAS_RPC.UPDATE_PERSONAL_TASKS` 的RPC，让服务器可以接收并保存客户端发来的个人任务列表。

#### **第2步：前端 - 修改UI布局和逻辑**

**1. 添加UI控件**

在 `atlasbook_ui.lua` 的 `_ctor` 中，修改团队计划视图 (`planner_view`)：

*   在顶部添加两个按钮，比如 "团队" 和 "个人"，用于切换列表模式。
*   或者使用一个下拉菜单。

```lua
-- 在 planner_view 中添加
self.team_plan_button = self.planner_view:AddChild(TEMPLATES.StandardButton(function() self:SetPlannerMode("team") end, "团队", {100, 40}))
self.team_plan_button:SetPosition(-60, 220, 0)

self.personal_plan_button = self.planner_view:AddChild(TEMPLATES.StandardButton(function() self:SetPlannerMode("personal") end, "个人", {100, 40}))
self.personal_plan_button:SetPosition(60, 220, 0)

-- 添加一个变量来记录当前是哪种模式
self.planner_mode = "team" -- 默认是团队模式
```

**2. 实现 `SetPlannerMode` 函数**

这个函数负责切换模式，并刷新列表。

```lua
function AtlasBookUI:SetPlannerMode(mode)
    if self.planner_mode == mode then return end -- 如果模式没变，就什么都不做

    self.planner_mode = mode
    
    -- 更新按钮样式来高亮当前模式
    if mode == "team" then
        self.team_plan_button:SetTextColour(0.8, 0, 0, 1)
        self.personal_plan_button:SetTextColour(0, 0, 0, 1)
    else -- personal
        self.team_plan_button:SetTextColour(0, 0, 0, 1)
        self.personal_plan_button:SetTextColour(0.8, 0, 0, 1)
    end
    
    -- 切换模式后，立即刷新任务列表
    self:UpdateTaskList()
end
```

**3. 修改核心函数以适应不同模式**

现在，所有与任务列表交互的函数都需要知道当前是哪种模式。

*   **`UpdateTaskList`**：需要从不同的地方获取数据。

```lua
function AtlasBookUI:UpdateTaskList()
    local tasks = {}
    if self.planner_mode == "team" then
        -- 从世界组件获取团队任务
        if TheWorld and TheWorld.components and TheWorld.components.atlas_todolist then
            tasks = TheWorld.components.atlas_todolist:GetTasks()
        end
    else -- personal
        -- 从玩家自己的组件获取个人任务
        if self.owner and self.owner.components and self.owner.components.atlas_personaltodolist then
            tasks = self.owner.components.atlas_personaltodolist:GetTasks()
        end
    end
    
    tasks = tasks or {}
    
    -- 后续的UI创建逻辑不变...
end
```

*   **`CreateTaskItem`**：按钮的回调函数需要调用正确的组件方法。

```lua
function AtlasBookUI:CreateTaskItem(task)
    -- ...
    -- 状态按钮的回调
    status_button:SetOnClick(function()
        if self.planner_mode == "team" then
            TheWorld.components.atlas_todolist:ToggleTask(task.id, not task.completed)
        else
            self.owner.components.atlas_personaltodolist:ToggleTask(task.id, not task.completed)
        end
        -- 注意：个人任务列表的修改是即时的，但团队任务需要等待服务器回包
        -- 为了统一，可以都依赖事件来刷新UI，或者个人模式下直接刷新
        self:UpdateTaskList() 
    end)
    
    -- 删除按钮的回调 (逻辑类似)
    -- ...
end
```

*   **添加任务的逻辑**：`OnSignInputComplete` 也需要根据模式调用不同的 `AddTask`。

```lua
function AtlasBookUI:OnSignInputComplete(text)
    if text and text:gsub("%s+", "") ~= "" then
        if self.planner_mode == "team" then
            TheWorld.components.atlas_todolist:AddTask(text)
        else
            self.owner.components.atlas_personaltodolist:AddTask(text)
            -- 个人任务添加后，可以立即刷新UI
            self:UpdateTaskList()
        end
    end
end
```

**4. 添加新的事件监听器**

在 `_ctor` 中，除了监听团队列表的更新，还要监听个人列表的更新。

```lua
-- 监听个人任务列表更新（例如，从服务器加载存档后）
if not self.personal_task_update_listener then
    self.personal_task_update_listener = self.owner:ListenForEvent("atlas_personaltodolist_updated", function()
        -- 只有在当前是个人模式时才需要立即刷新
        if self.planner_mode == "personal" then
            self:UpdateTaskList()
        end
    end)
end
```

通过以上步骤，你就成功地将单一的团队计划功能扩展为了一个功能更丰富的、支持团队与个人两种模式的混合计划系统。 
