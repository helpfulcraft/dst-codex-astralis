好的，遵命。这是一份为你量身定制的、采用待办清单（Todolist）形式的实施计划（Implementation Plan / RFC）。它结构清晰，你可以按照这个清单一步步将你的想法变为现实。

---

### **IMP (Implementation Plan): "万象全书" (Universal Guide) 模组开发**

*   **项目代号:** Project Atlas
*   **版本:** 1.0 (Draft)
*   **作者:** (Your Name Here)
*   **日期:** 2023年10月27日
*   **状态:** 草案

#### **摘要 (Abstract)**

本项目旨在为《饥荒：联机版》开发一个名为“万象全书”的多功能指南模组。该模组以一本出生自带的书籍为载体，旨在通过三个核心阶段的开发，从一个静态的新手指南，逐步演进为一个集成了团队协作规划工具和AI智能问答助手的综合性游戏内信息中心，最终目标是无缝化游戏体验，减少玩家对外部工具的依赖。

#### **动机 (Motivation)**

1.  **降低新手门槛:** 新手玩家常常需要频繁切换窗口查询攻略，严重打断游戏沉浸感。
2.  **解决团队规划痛点:** 生存建设类游戏中，团队成员间的信息同步和任务规划是核心痛点。“今天我们该干啥？”是常见问题。
3.  **拥抱前沿技术:** 将LLM技术集成到游戏中，提供一种全新的、即时的、上下文相关的问答体验，是模组功能的未来探索方向。

---

### **实施计划清单 (Implementation Checklist)**

#### **阶段 0: 准备工作 (Prerequisites)**

*   [x] 安装《Don't Starve Together》客户端。
*   [x] 安装 Klei 官方提供的《Don't Starve Mod Tools》。
*   [x] 配置一个代码编辑器（如 VS Code）并安装 Lua 语言支持插件。
*   **[ ] 1. 手动创建模组文件夹:**
    *   [x] 前往您的饥荒模组目录，通常位于 `..\Steam\steamapps\common\Don't Starve Together\mods\`。
    *   [x] 在该目录下，创建一个新的文件夹来存放您的模组，命名为 `Codex Astralis` (或者您喜欢的任何英文名)。

*   **[ ] 2. 创建核心配置文件 `modinfo.lua`:**
    *   [x] 在您刚刚创建的 `Codex Astralis` 文件夹内，新建一个文本文档，并将其重命名为 `modinfo.lua`。
    *   [x] 使用您的代码编辑器打开它，然后将以下基础配置代码**复制粘贴**进去：

    ```lua
    -- 这是模组的“身份证”，告诉游戏和Steam创意工坊你的模组是什么。
    name = "Codex Astralis (天书指南)"
    description = "一本出生自带的超级指南，内置新手攻略、团队规划和AI助手！\nA super guide book you spawn with, featuring beginner's guides, team planner, and an AI assistant!"
    author = "（在这里填上您的作者名）"
    version = "0.1.0" -- 初始开发版本

    -- 这是一个非常重要的版本号，请保持为10
    api_version = 10
    -- 这是一个非常重要的版本号，请保持为6
    api_version_dst = 6

    -- 标记这个模组是联机版（DST）专用的
    dst_compatible = true

    -- 客户端模组（所有玩家都需要）还是仅服务器模组
    client_only_mod = false
    all_clients_require_mod = true

    -- 模组图标
    icon_atlas = "modicon.xml"
    icon = "modicon.tex"
    ```

*   **[ ] 3. 创建主逻辑文件 `modmain.lua`:**
    *   [x] 同样，在 `Codex Astralis` 文件夹内，新建一个文本文档，重命名为 `modmain.lua`。
    *   [x] 目前，您只需在里面留下一句注释，表示我们知道它的作用即可：

    ```lua
    -- 这是模组的主逻辑文件，所有功能的入口和魔法的起点。
    -- 我们将在这里编写出生自带书本、打开UI等核心代码。
    ```

*   **[ ] 4. (可选但推荐) 创建一个模组图标:**
    *   [x] 制作或寻找一张 128x128像素 的 .png 图片作为您的模组图标，命名为 `modicon.png` 并放入 `Codex Astralis` 文件夹。
    *   *(注：后续需要工具将其转换为游戏使用的 .tex 和 .xml 格式，但现在先准备好源文件即可)*
---

### **阶段 1: 初级版 - 静态攻略书 (The Static Codex)**

*   **核心目标: 一个包含预设图文内容、可翻页、有目录、能记忆位置的书。**

#### **[1.1] 物品创建 (Item Prefab)**

*   **[1.1.1] 创建物品定义文件**
    *   [x] 在你的模组文件夹的 `scripts/prefabs/` 目录下，创建一个新文件，命名为 `atlas_book.lua`。这是定义你书本物品行为的地方。

*   **[1.1.2] 编写基础代码**
    *   [x] 在 `atlas_book.lua` 文件中，写入以下基础结构代码：
        ```lua
        local function fn()
            local inst = CreateEntity()
            -- 这里是物品的主要逻辑
            return inst
        end

        return Prefab("atlas_book", fn, assets)
        ```

*   **[1.1.3] 设计并添加物品资源**
    *   [x] 设计一个物品栏图标，比如一个 `64x64` 像素的 `.png` 图片。
    *   [x] 在模组的 `exported/` 目录下创建一个新文件夹 
    *   [x] 将你的图标图片（例如 `atlas_book.png`）放进 `exported 文件夹。
    *   [ ] 使用游戏自带的 `autocompiler` 工具来生成 `.tex` 和 `.xml` 文件。
    *   [ ] 在 `atlas_book.lua` 的顶部，添加资源引用：
        ```lua
        local assets = {
            Asset("ATLAS", "images/inventoryimages/atlas_book.xml"),
            Asset("IMAGE", "images/inventoryimages/atlas_book.tex"),
        }
        ```

*   **[1.1.4] 添加核心组件**
    *   [ ] 在 `atlas_book.lua` 的 `fn` 函数中，添加以下代码，让它成为一个可以被拾取和使用的物品：
        ```lua
        local inst = CreateEntity()

        inst.entity:AddTransform()
        inst.entity:AddAnimState()
        inst.entity:AddNetwork()

        MakeInventoryPhysics(inst)

        inst.AnimState:SetBank("books")
        inst.AnimState:SetBuild("book_cookbook") -- 可以暂时借用游戏自带的模型
        inst.AnimState:PlayAnimation("idle")

        inst:AddTag("atlas_book") -- 给物品一个标签，方便以后查找

        inst.entity:SetPristine()

        if not TheWorld.ismastersim then
            return inst
        end

        -- [核心] 使其可被携带
        inst:AddComponent("inventoryitem")
        inst.components.inventoryitem.imagename = "atlas_book"
        inst.components.inventoryitem.atlasname = "images/inventoryimages/atlas_book.xml"

        -- [核心] 定义右键使用行为
        inst:AddComponent("useitem")
        inst.components.useitem:SetOnUseFn(function(user)
            -- 这个函数会在玩家右键点击书本时触发
            -- TODO: 在这里编写打开UI的逻辑
            -- 例如：user.HUD.controls.atlasbook:Open(user)
        end)

        return inst
        ```

#### **[1.2] UI 界面开发 (User Interface)**

*   **[1.2.1] 创建UI定义文件**
    *   [ ] 在你的模组文件夹的 `scripts/widgets/` 目录下，创建一个新文件，命名为 `atlasbook_ui.lua`。

*   **[1.2.2] 编写UI基础框架**
    *   [ ] 在 `atlasbook_ui.lua` 中，写入以下框架代码。这是一个标准的UI控件写法：
        ```lua
        local Screen = require "widgets/screen"
        local Button = require "widgets/button"
        local Image = require "widgets/image"
        local Text = require "widgets/text"
        -- ... 其他你需要的控件

        local AtlasBookUI = Class(Screen, function(self, owner)
            self.owner = owner -- owner 就是打开这本书的玩家
            Screen._ctor(self, "AtlasBookUI")

            -- UI布局和元素将在这里创建
        end)

        return AtlasBookUI
        ```

*   **[1.2.3] 布局设计与实现**
    *   [ ] 在 `AtlasBookUI` 的构造函数中，创建背景、目录区和内容区。
        ```lua
        -- ... 构造函数内部 ...
        -- 背景
        self.black = self:AddChild(Image("images/global.xml", "black.tex"))
        self.black:SetVRegPoint(ANCHOR_MIDDLE)
        self.black:SetHRegPoint(ANCHOR_MIDDLE)
        self.black:SetScaleMode(SCALEMODE_FILLSCREEN)

        -- 书本根节点，所有元素都附着在它上面
        self.root = self:AddChild(Widget("root"))
        self.root:SetPosition(0, 0, 0)

        -- 目录区 (Area A)
        self.menu_root = self.root:AddChild(Widget("menu_root"))
        self.menu_root:SetPosition(-400, 0, 0) -- 举例：放在左边

        -- 内容区 (Area B)
        self.content_root = self.root:AddChild(Widget("content_root"))
        self.content_root:SetPosition(150, 0, 0) -- 举例：放在右边
        ```

*   **[1.2.4] 内容数据化**
    *   [ ] 为了方便管理，在 `scripts/` 目录下创建一个新文件 `atlas_book_data.lua`。
    *   [ ] 在 `atlas_book_data.lua` 中，用一个 Lua `table` 存储所有章节内容：
        ```lua
        return {
            chapter1 = {
                title = "开局前三天",
                text = "第一天：收集树枝、草、燧石...\n第二天：制作斧头和稿子...",
                image = "images/custom_images/day1.xml", -- 图片路径
                tex = "day1.tex",
            },
            chapter2 = {
                title = "四季应对",
                text = "春天会下雨，注意防潮...",
                image = "images/custom_images/seasons.xml",
                tex = "seasons.tex",
            },
            -- ...更多章节
        }
        ```
    *   [ ] 将你需要的图片素材（如 `day1.png`, `seasons.png`）放入模zǔ的 `exported/custom_images/` 文件夹，并用 `autocompiler` 生成 `.tex` 和 `.xml`。

*   **[1.2.5] 动态内容实现**
    *   [ ] 在 `atlasbook_ui.lua` 中，加载数据并创建内容控件。
        ```lua
        -- 在文件顶部加载数据
        local BookData = require "atlas_book_data"

        -- 在构造函数中创建内容控件
        self.content_title = self.content_root:AddChild(Text(UIFONT, 35))
        self.content_text = self.content_root:AddChild(Text(UIFONT, 25))
        self.content_image = self.content_root:AddChild(Image())
        ```
    *   [ ] 在 `AtlasBookUI` 中，编写一个函数来更新内容。
        ```lua
        function AtlasBookUI:SetChapter(chapter_id)
            local data = BookData[chapter_id]
            if data then
                self.content_title:SetString(data.title)
                self.content_text:SetString(data.text)
                self.content_image:SetTexture(data.image, data.tex)
                self.current_chapter_id = chapter_id -- 记录当前章节
            end
        end
        ```

*   **[1.2.6] 目录按钮实现**
    *   [ ] 在 `AtlasBookUI` 的构造函数中，遍历数据来创建按钮。
        ```lua
        local y_offset = 150
        for id, data in pairs(BookData) do
            local button = self.menu_root:AddChild(Button())
            button:SetText(data.title)
            button:SetPosition(0, y_offset, 0)
            button.onclick = function()
                self:SetChapter(id) -- 点击按钮时，调用SetChapter函数
            end
            y_offset = y_offset - 50 -- 让下一个按钮在下方
        end
        ```

*   **[1.2.7] 连接物品与UI**
    *   [ ] 回到 `modmain.lua`，在 `modmain.lua` 中注册你的UI，这样游戏才能识别它。
        ```lua
        -- 在 modmain.lua 顶部添加
        local AtlasBookUI = require "widgets/atlasbook_ui"

        -- 在 AddClassPostConstruct("screens/playerhud", ...) 中添加
        local controls = inst.controls
        controls.atlasbook = controls:AddChild(AtlasBookUI(inst.owner))
        controls.atlasbook:Hide() -- 默认隐藏

        function controls.atlasbook:Open()
            self:Show()
            self.focus = true
        end

        function controls.atlasbook:Close()
            self:Hide()
            self.focus = false
        end
        ```
    *   [ ] 回到 `atlas_book.lua`，修改 `onuse` 函数来真正打开UI。
        ```lua
        inst.components.useitem:SetOnUseFn(function(user)
            if user.HUD and user.HUD.controls and user.HUD.controls.atlasbook then
                user.HUD.controls.atlasbook:Open()
            end
        end)
        ```

#### **[1.3] 核心功能实现 (Core Logic)**

*   **[1.3.1] 出生自带**
    *   [ ] 在 `modmain.lua` 中，找到或添加 `AddPrefabPostInit("player_classified", ...)` 函数。
    *   [ ] 在这个函数里，监听玩家激活事件，并在玩家首次进入世界时给予书本。
        ```lua
        AddPrefabPostInit("player_classified", function(inst)
            inst:ListenForEvent("ms_playeractivated", function(inst, player)
                -- 确保只在主机端执行，并且只给一次
                if TheWorld.ismastersim and not player.persists.has_atlas_book then
                    player.components.inventory:GiveItem(SpawnPrefab("atlas_book"))
                    player.persists.has_atlas_book = true
                end
            end)
        end)
        ```

*   **[1.3.2] 记忆位置**
    *   [ ] 在 `atlasbook_ui.lua` 中，找到 `AtlasBookUI` 的类定义。
    *   [ ] 添加 `OnClose` 方法，在UI关闭时保存当前章节ID。
        ```lua
        function AtlasBookUI:OnClose()
            if self.owner and self.current_chapter_id then
                self.owner.persists.atlas_book_lastpage = self.current_chapter_id
            end
        end
        ```
    *   [ ] 修改 `Open` (或 `OnBecomeActive`) 方法，在UI打开时读取并跳转到上次的页面。
        ```lua
        function AtlasBookUI:Open() -- 或者在构造函数里
            self:Show()
            self.focus = true
            -- 读取并设置页面
            local last_page_id = self.owner.persists.atlas_book_lastpage or "chapter1" -- 如果没有记录，就打开第一章
            self:SetChapter(last_page_id)
        end
        ```

---

#### **阶段 2: 中级版 - 协作规划器 (The Collaborative Planner)**

*   **核心目标: 在书中集成一个团队共享、实时同步的 Todolist。**

*   **[2.1] UI 扩展 (UI Extension)**
    *   [ ] 在书本UI中添加一个新的标签页，命名为“团队计划”。
    *   [ ] 在该标签页内，添加以下控件：
        *   [ ] 一个文本输入框 (`TextInput`) 用于输入新任务。
        *   [ ] 一个“添加任务”按钮。
        *   [ ] 一个可滚动的列表区域，用于显示所有任务。
        *   [ ] 为列表中的每一行任务设计模板，包含：任务文本、复选框 (`ImageButton`)、删除按钮。

*   **[2.2] 数据结构与存储 (Data Structure)**
    *   [ ] **服务器端:** 设计一个全局的数据结构来存储 Todolist，例如 `TheWorld.components.atlastodolist`，其内容为一个任务对象的数组 `{{text="...", completed=false}, ...}`。
    *   [ ] **客户端:** 客户端不需要永久存储这个列表，每次都从服务器获取最新版本。

*   **[2.3] 网络同步 (Networking - RPC)**
    *   [ ] **客户端 -> 服务器:**
        *   [ ] 实现一个函数，当玩家点击“添加任务”按钮时，通过 `SendModRPCToServer()` 发送一个包含新任务文本的RPC。
        *   [ ] 实现一个函数，当玩家点击“复选框”时，发送一个包含任务ID和新状态的RPC。
        *   [ ] 实现一个函数，当玩家点击“删除按钮”时，发送一个包含任务ID的RPC。
    *   [ ] **服务器端处理:**
        *   [ ] 编写代码来接收并处理上述三种RPC，对 `TheWorld.components.atlastodolist` 中的数据进行增、改、删。
    *   [ ] **服务器 -> 客户端:**
        *   [ ] 创建一个广播函数。每当服务器上的 Todolist 数据发生变化时，调用此函数。
        *   [ ] 此函数通过 `SendModRPCToClient()` 将**完整、最新**的 Todolist 数据广播给所有连接的客户端。
    *   [ ] **客户端更新:**
        *   [ ] 编写代码来接收服务器的广播RPC。
        *   [ ] 收到新的列表数据后，清空本地UI列表，并根据新数据重新渲染整个 Todolist 界面。

---

#### **阶段 3: 高级版 - AI 助手 (The AI Assistant)**

*   **核心目标: 集成一个可以通过 API 调用外部 LLM 的问答模块。**

*   **[3.1] 配置与UI (Configuration & UI)**
    *   [ ] **模组配置:** 创建一个 `modsettings.lua` 文件，在模组配置菜单中增加一个输入框，让玩家可以填入自己的 API Key。
    *   [ ] **UI扩展:**
        *   [ ] 在书本UI中再添加一个标签页，命名为“智能问答”。
        *   [ ] 添加一个大的文本输入框用于提问，一个“提问”按钮。
        *   [ ] 添加一个用于显示“正在思考中...”的加载指示器。
        *   [ ] 添加一个用于显示最终答案的文本区域。

*   **[3.2] 异步网络请求 (Asynchronous HTTP)**
    *   [ ] 研究并选择实现HTTP请求的方法（Klei 提供的 `TheNet:GetHTTP()` 或捆绑 `luasocket`）。
    *   [ ] **实现异步调用:**
        *   [ ] 将整个网络请求的逻辑封装在一个**协程 (Coroutine)** 中。
        *   [ ] 当玩家点击“提问”时，启动这个协程。
        *   [ ] 在协程中，构造HTTP请求（URL、包含API Key的Header、包含问题的Body）。
        *   [ ] 发出请求后，立刻 `coroutine.yield()`，将控制权还给游戏主线程，避免游戏卡死。
    *   [ ] **处理响应:**
        *   [ ] 在HTTP请求的回调函数中，`coroutine.resume()` 协程。
        *   [ ] 在恢复的协程中，解析返回的JSON数据。
        *   [ ] 提取出答案文本，并更新到UI的答案区域。
    *   [ ] **错误处理:**
        *   [ ] 实现对网络超时、无效API Key、API返回错误等情况的处理，并在UI上向玩家显示清晰的错误信息。

*   **[3.3] 体验优化 (UX Improvements)**
    *   [ ] **异步问答:** 确保在提问后关闭书本，后台的请求依然在进行。
    *   [ ] **答案持久化与推送:**
        *   [ ] 当答案返回时，无论书本是否打开，都将问题和答案保存到 `player.persists` 中。
        *   [ ] （可选）当答案返回时，使用 `TheFrontEnd:ShowAnnoucement()` 给玩家一个屏幕提示，如“万象全书：您的问题已有回答。”
        *   [ ] 玩家下次打开书的AI页面时，自动加载并显示上一次的问答记录。